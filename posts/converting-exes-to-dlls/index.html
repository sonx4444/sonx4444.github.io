<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://sonx4444.github.io name=base><title>
            
                Converting Exes to DLLs
            
        </title><meta content="Converting Exes to DLLs" property=og:title><link href=https://sonx4444.github.io/fonts.css rel=stylesheet><link media="(prefers-color-scheme: dark)" href=/syntax-theme-dark.css rel=stylesheet><link media="(prefers-color-scheme: light)" href=/syntax-theme-light.css rel=stylesheet><script data-host-url=https://api-gateway.umami.dev/ data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e defer src=/js/imamu.js></script><script async data-goatcounter=https://sonx4444.goatcounter.com/count src=https://sonx4444.github.io/js/count.js></script><noscript><img src="https://sonx4444.goatcounter.com//count?p=/posts/converting-exes-to-dlls/&t=Converting Exes to DLLs"></noscript><link href=https://sonx4444.github.io/atom.xml rel=alternate title=sonx4444 type=application/atom+xml><link href=https://sonx4444.github.io/rss.xml rel=alternate title=sonx4444 type=application/rss+xml><link href=https://sonx4444.github.io/theme/light.css rel=stylesheet><link href=https://sonx4444.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://sonx4444.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://sonx4444.github.io/main.css media=screen rel=stylesheet><body><div class=left-content></div><div class=content><nav><div class=left-nav><a href=https://sonx4444.github.io>sonx4444</a><div class=socials><a class=social href=https://x.com/sonx4444 rel=me> <img alt=twitter src=https://sonx4444.github.io/icons/social/twitter.svg> </a><a class=social href=https://github.com/sonx4444/ rel=me> <img alt=github src=https://sonx4444.github.io/icons/social/github.svg> </a><a class=social href=/atom.xml rel=me> <img alt=rss src=https://sonx4444.github.io/icons/social/rss.svg> </a></div></div><div class=right-nav><a href=https://sonx4444.github.io/posts style=margin-right:.5em>/posts</a><a href=https://sonx4444.github.io/tags style=margin-right:.5em>/tags</a><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://sonx4444.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://sonx4444.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></div></nav><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>Converting Exes to DLLs</div><div class=meta>Posted on <time>2025-07-01</time><span class=tags-label> :: </span><span class=tags> <a class=post-tag href=https://sonx4444.github.io/tags/windows/>windows</a> <a class=post-tag href=https://sonx4444.github.io/tags/rev/>rev</a> </span></div></div><section class=body><p>If you’ve worked with Windows applications, you’re likely familiar with EXE (executable) and DLL (dynamic link library) files. While these file types serve different purposes, they share a common underlying structure called <strong>PE (Portable Executable)</strong>. This shared structure is what makes it technically possible to convert an EXE into a DLL.<p>This process is mainly educational—it’s a practical way to learn about the PE format, binary structure, and Windows internals.<p>In this post, we'll cover the key differences between EXEs and DLLs and walk through the technical steps to convert an EXE to a DLL.<h2 id=key-differences-between-exes-and-dlls>Key Differences Between EXEs and DLLs</h2><p>Here are the main factors that distinguish DLLs from EXEs:<ol><li><strong>DLL Flag</strong>: The PE file header contains a flag called <code>IMAGE_FILE_DLL</code>. When this flag is set, Windows recognizes the file as a DLL.<li><strong>Export Directory</strong>: DLLs contain an export directory with one or more entries. Each entry represents a function or variable that other programs can import and use.<li><strong>Entry Point Handling</strong>: Both file types have entry points, but they function differently: <ul><li>In EXEs: The entry point marks where program execution begins.<li>In DLLs: The entry point is called <code>DllMain</code> and is invoked when the DLL is loaded (attached) or unloaded (detached).</ul><li><strong>Relocations</strong>: This is a crucial difference. Relocations are used to adjust memory addresses when the binary is loaded at a different location than its preferred base address: <ul><li>EXEs can run without relocations.<li>DLLs must have a relocation table to function properly. This is because DLLs can be loaded at any address in a process's memory space, depending on what other modules are already loaded. Without relocations, the DLL would fail to initialize if it can't be loaded at its preferred address.</ul></ol><h2 id=converting-exe-to-dll-the-technical-process>Converting EXE to DLL: The Technical Process</h2><p>To convert an EXE into a DLL, we need to make the following modifications:<ol><li>Verify that the EXE has a relocation table (this is a prerequisite).<li>Set the <code>IMAGE_FILE_DLL</code> flag in the PE file header.<li>Redirect the original entry point to a custom <code>DllMain</code> function.<li>Create an Export Directory that points to the original entry point.</ol><h2 id=implementation>Implementation</h2><p>Let's walk through the actual implementation of each step. Our code handles both 32-bit and 64-bit executables.<h3 id=1-preliminary-checks>1. Preliminary Checks</h3><p>Before starting the conversion, we need to verify two critical requirements:<pre class="language-cpp z-code" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-source z-c++"><span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Verify the input is a valid executable
</span></span><span class="z-source z-c++"><span class="z-keyword z-control z-c++">if</span> <span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-keyword z-operator z-arithmetic z-c">!</span><span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">is_exe</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">buffer<span class="z-punctuation z-accessor z-dot z-c++">.</span><span class="z-meta z-method-call z-c++"><span class="z-variable z-function z-member z-c++">data</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-method-call z-c++"></span><span class="z-meta z-method-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>cerr <span class="z-keyword z-operator z-arithmetic z-c"><<</span> <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">"</span>The file is not a valid EXE<span class="z-punctuation z-definition z-string z-end z-c">"</span></span> <span class="z-keyword z-operator z-arithmetic z-c"><<</span> std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>endl<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    <span class="z-keyword z-control z-flow z-return z-c++">return</span> <span class="z-constant z-numeric z-integer z-decimal z-c++">1</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span>
</span><span class="z-source z-c++">
</span><span class="z-source z-c++"><span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Ensure relocations exist
</span></span><span class="z-source z-c++"><span class="z-keyword z-control z-c++">if</span> <span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-keyword z-operator z-arithmetic z-c">!</span><span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">is_safe_to_convert</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">buffer<span class="z-punctuation z-accessor z-dot z-c++">.</span><span class="z-meta z-method-call z-c++"><span class="z-variable z-function z-member z-c++">data</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-method-call z-c++"></span><span class="z-meta z-method-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>cerr <span class="z-keyword z-operator z-arithmetic z-c"><<</span> <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">"</span>The file is not safe to convert (missing relocations)<span class="z-punctuation z-definition z-string z-end z-c">"</span></span> <span class="z-keyword z-operator z-arithmetic z-c"><<</span> std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>endl<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    <span class="z-keyword z-control z-flow z-return z-c++">return</span> <span class="z-constant z-numeric z-integer z-decimal z-c++">1</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span>
</span></code></pre><p>The second check is particularly important because DLLs must be relocatable to function properly in different memory locations.<h3 id=2-setting-the-dll-flag>2. Setting the DLL Flag</h3><p>The first modification is straightforward — we set the DLL flag in the PE file header:<pre class="language-cpp z-code" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-source z-c++">IMAGE_FILE_HEADER<span class="z-keyword z-operator z-c++">*</span> file_header <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-function-call z-c++">peforge<span class="z-punctuation z-accessor z-double-colon z-c++">::</span><span class="z-variable z-function z-c++">get_file_header</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">buffer</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span><span class="z-source z-c++">file_header<span class="z-punctuation z-accessor z-arrow z-c++">-></span><span class="z-variable z-other z-readwrite z-member z-c++">Characteristics</span> <span class="z-keyword z-operator z-assignment z-augmented z-c">|=</span> IMAGE_FILE_DLL<span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><h3 id=3-finding-and-using-code-caves>3. Finding and Using Code Caves</h3><p>Before we can implement our <code>DllMain</code> function and set up the export directory, we need to find places to store our new data structures and code. We use "code caves" — unused spaces within the executable's sections that are large enough to hold our additions.<h4 id=what-is-a-code-cave>What is a Code Cave?</h4><p>A code cave is an unused space between sections or within a section of the PE file. These spaces exist due to section alignment requirements and can be repurposed for our needs.<h4 id=finding-suitable-caves>Finding Suitable Caves</h4><pre class="language-cpp z-code" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-source z-c++"><span class="z-support z-type z-windows z-c">BYTE</span><span class="z-keyword z-operator z-c++">*</span> code_cave <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-function-call z-c++">peforge<span class="z-punctuation z-accessor z-double-colon z-c++">::</span><span class="z-variable z-function z-c++">get_minimum_cave</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">buffer<span class="z-punctuation z-separator z-c++">,</span> 
</span></span></span><span class="z-source z-c++"><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">                                          data_size <span class="z-keyword z-operator z-arithmetic z-c">+</span> <span class="z-constant z-numeric z-integer z-decimal z-c++">1</span><span class="z-punctuation z-separator z-c++">,</span>  <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> +1 for separator
</span></span></span></span><span class="z-source z-c++"><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">                                          <span class="z-keyword z-operator z-c">&</span>cave_size<span class="z-punctuation z-separator z-c++">,</span> 
</span></span></span><span class="z-source z-c++"><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">                                          characteristics</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><h4 id=cave-requirements>Cave Requirements</h4><ul><li>Must be large enough for the data plus a separator byte<li>Must have appropriate section characteristics (read/write/execute)<li>For code (like <code>DllMain</code>), we need executable caves<li>For data (names, addresses), we need readable caves</ul><h4 id=inserting-data>Inserting Data</h4><pre class="language-cpp z-code" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-source z-c++"><span class="z-support z-type z-windows z-c">BYTE</span><span class="z-keyword z-operator z-c++">*</span> data_location <span class="z-keyword z-operator z-assignment z-c">=</span> code_cave <span class="z-keyword z-operator z-arithmetic z-c">+</span> <span class="z-constant z-numeric z-integer z-decimal z-c++">1</span><span class="z-punctuation z-terminator z-c++">;</span> <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Skip one byte as separator
</span></span><span class="z-source z-c++"><span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">memcpy</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">data_location<span class="z-punctuation z-separator z-c++">,</span> data<span class="z-punctuation z-separator z-c++">,</span> data_size</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><p>We need caves for several components:<ul><li><code>DllMain</code> function code (needs executable permission)<li>Export function name string<li>DLL name string<li>Function address array<li>Name pointer array<li>Ordinals array<li>Export directory structure</ul><p>Each insertion follows this pattern:<pre class="language-cpp z-code" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-source z-c++"><span class="z-support z-type z-windows z-c">BYTE</span><span class="z-keyword z-operator z-c++">*</span> cave <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">insert_to_code_cave</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">buffer<span class="z-punctuation z-separator z-c++">,</span> size<span class="z-punctuation z-separator z-c++">,</span> data<span class="z-punctuation z-separator z-c++">,</span> data_size<span class="z-punctuation z-separator z-c++">,</span> characteristics</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span><span class="z-source z-c++"><span class="z-keyword z-control z-c++">if</span> <span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-keyword z-operator z-arithmetic z-c">!</span>cave<span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>cerr <span class="z-keyword z-operator z-arithmetic z-c"><<</span> <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">"</span>Failed to find suitable cave<span class="z-punctuation z-definition z-string z-end z-c">"</span></span> <span class="z-keyword z-operator z-arithmetic z-c"><<</span> std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>endl<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    <span class="z-keyword z-control z-flow z-return z-c++">return</span> <span class="z-constant z-language z-c">false</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span>
</span></code></pre><p>After inserting data into a cave, we convert the file offset to a Relative Virtual Address (RVA):<pre class="language-cpp z-code" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-source z-c++"><span class="z-support z-type z-windows z-c">DWORD</span> offset <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-keyword z-operator z-word z-cast z-c++">static_cast</span><span class="z-punctuation z-section z-generic z-begin z-c++"><</span><span class="z-support z-type z-windows z-c">DWORD</span><span class="z-punctuation z-section z-generic z-end z-c++">></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span>cave <span class="z-keyword z-operator z-arithmetic z-c">-</span> buffer<span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span><span class="z-source z-c++"><span class="z-support z-type z-windows z-c">DWORD</span> rva <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-numeric z-integer z-decimal z-c++">0</span><span class="z-punctuation z-terminator z-c++">;</span>
</span><span class="z-source z-c++"><span class="z-keyword z-control z-c++">if</span> <span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-keyword z-operator z-arithmetic z-c">!</span><span class="z-meta z-function-call z-c++">peforge<span class="z-punctuation z-accessor z-double-colon z-c++">::</span><span class="z-variable z-function z-c++">offset_to_rva</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">buffer<span class="z-punctuation z-separator z-c++">,</span> size<span class="z-punctuation z-separator z-c++">,</span> offset<span class="z-punctuation z-separator z-c++">,</span> rva</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>cerr <span class="z-keyword z-operator z-arithmetic z-c"><<</span> <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">"</span>Failed to convert offset to RVA<span class="z-punctuation z-definition z-string z-end z-c">"</span></span> <span class="z-keyword z-operator z-arithmetic z-c"><<</span> std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>endl<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    <span class="z-keyword z-control z-flow z-return z-c++">return</span> <span class="z-constant z-language z-c">false</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span>
</span></code></pre><p>This RVA conversion is crucial because PE files use RVAs in their data structures rather than file offsets.<h3 id=4-creating-a-dllmain-function>4. Creating a DllMain Function</h3><p>Now that we understand how to use code caves, we can create a minimal <code>DllMain</code> function that returns TRUE (1) to indicate successful initialization. The implementation differs slightly between 32-bit and 64-bit:<pre class="language-cpp z-code" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-source z-c++"><span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> 32-bit version
</span></span><span class="z-source z-c++"><span class="z-support z-type z-windows z-c">BYTE</span> dll_main_32<span class="z-meta z-brackets z-c++"><span class="z-punctuation z-section z-brackets z-begin z-c++">[</span><span class="z-punctuation z-section z-brackets z-end z-c++">]</span></span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>B8</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>01</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>00</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>00</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>00</span><span class="z-punctuation z-separator z-c++">,</span>   <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> mov eax, 1
</span></span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>C2</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>0C</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>00</span>                <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> retn 0x0C
</span></span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span><span class="z-source z-c++">
</span><span class="z-source z-c++"><span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> 64-bit version
</span></span><span class="z-source z-c++"><span class="z-support z-type z-windows z-c">BYTE</span> dll_main_64<span class="z-meta z-brackets z-c++"><span class="z-punctuation z-section z-brackets z-begin z-c++">[</span><span class="z-punctuation z-section z-brackets z-end z-c++">]</span></span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>B8</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>01</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>00</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>00</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>00</span><span class="z-punctuation z-separator z-c++">,</span>   <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> mov eax, 1
</span></span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    <span class="z-constant z-numeric z-integer z-hexadecimal z-c++"><span class="z-punctuation z-definition z-numeric z-base z-c++">0x</span>C3</span>                            <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> retn
</span></span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><p>This machine code is inserted into one of the executable code caves we identified earlier. The key difference is in the return instruction: 32-bit DLLs need to clean up the stack (<code>retn 0x0C</code>), while 64-bit uses the simpler <code>ret</code>.<h3 id=5-updating-the-entry-point>5. Updating the Entry Point</h3><p>After creating our <code>DllMain</code> function, we need to perform a crucial step: redirecting the executable's entry point. This involves:<ol><li>Saving the original entry point (OEP) for later use as our exported function:</ol><pre class="language-cpp z-code" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-source z-c++"><span class="z-support z-type z-windows z-c">DWORD</span> oep <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-function-call z-c++">peforge<span class="z-punctuation z-accessor z-double-colon z-c++">::</span><span class="z-variable z-function z-c++">get_entry_point</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">buffer</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><ol start=2><li>Updating the PE header to point to our new <code>DllMain</code>:</ol><pre class="language-cpp z-code" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-source z-c++"><span class="z-keyword z-control z-c++">if</span> <span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-keyword z-operator z-arithmetic z-c">!</span><span class="z-meta z-function-call z-c++">peforge<span class="z-punctuation z-accessor z-double-colon z-c++">::</span><span class="z-variable z-function z-c++">update_entry_point</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">buffer<span class="z-punctuation z-separator z-c++">,</span> dll_main_rva</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>cerr <span class="z-keyword z-operator z-arithmetic z-c"><<</span> <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">"</span>Failed to update entry point<span class="z-punctuation z-definition z-string z-end z-c">"</span></span> <span class="z-keyword z-operator z-arithmetic z-c"><<</span> std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>endl<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++">    <span class="z-keyword z-control z-flow z-return z-c++">return</span> <span class="z-constant z-language z-c">false</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-source z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span>
</span></code></pre><p>This redirection ensures that when the DLL is loaded, Windows will call our <code>DllMain</code> function first. The original entry point is preserved and will be exposed as the exported function that other programs can call.<h3 id=6-setting-up-the-export-directory>6. Setting Up the Export Directory</h3><p>The export directory is what makes the DLL's functions accessible to other programs. We create it in several steps:<ol><li>First, we create the main export directory structure:</ol><pre class="language-cpp z-code" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-source z-c++">IMAGE_EXPORT_DIRECTORY export_dir <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span><span class="z-constant z-numeric z-integer z-decimal z-c++">0</span><span class="z-punctuation z-section z-block z-end z-c++">}</span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span><span class="z-source z-c++">export_dir<span class="z-punctuation z-accessor z-dot z-c++">.</span><span class="z-variable z-other z-readwrite z-member z-c++">Name</span> <span class="z-keyword z-operator z-assignment z-c">=</span> dll_main_name_rva<span class="z-punctuation z-terminator z-c++">;</span>          <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> DLL name
</span></span><span class="z-source z-c++">export_dir<span class="z-punctuation z-accessor z-dot z-c++">.</span><span class="z-variable z-other z-readwrite z-member z-c++">Base</span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-numeric z-integer z-decimal z-c++">1</span><span class="z-punctuation z-terminator z-c++">;</span>                          <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Starting ordinal number
</span></span><span class="z-source z-c++">export_dir<span class="z-punctuation z-accessor z-dot z-c++">.</span><span class="z-variable z-other z-readwrite z-member z-c++">NumberOfFunctions</span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-numeric z-integer z-decimal z-c++">1</span><span class="z-punctuation z-terminator z-c++">;</span>             <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> We're exporting one function
</span></span><span class="z-source z-c++">export_dir<span class="z-punctuation z-accessor z-dot z-c++">.</span><span class="z-variable z-other z-readwrite z-member z-c++">NumberOfNames</span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-numeric z-integer z-decimal z-c++">1</span><span class="z-punctuation z-terminator z-c++">;</span>                 <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> With one name
</span></span><span class="z-source z-c++">export_dir<span class="z-punctuation z-accessor z-dot z-c++">.</span><span class="z-variable z-other z-readwrite z-member z-c++">AddressOfFunctions</span> <span class="z-keyword z-operator z-assignment z-c">=</span> functions_rva<span class="z-punctuation z-terminator z-c++">;</span> <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Points to function addresses
</span></span><span class="z-source z-c++">export_dir<span class="z-punctuation z-accessor z-dot z-c++">.</span><span class="z-variable z-other z-readwrite z-member z-c++">AddressOfNames</span> <span class="z-keyword z-operator z-assignment z-c">=</span> names_rva<span class="z-punctuation z-terminator z-c++">;</span>        <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Points to function names
</span></span><span class="z-source z-c++">export_dir<span class="z-punctuation z-accessor z-dot z-c++">.</span><span class="z-variable z-other z-readwrite z-member z-c++">AddressOfNameOrdinals</span> <span class="z-keyword z-operator z-assignment z-c">=</span> ordinals_rva<span class="z-punctuation z-terminator z-c++">;</span> <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Maps names to functions
</span></span></code></pre><ol start=2><li><p>We store the original entry point as the exported function's address. This allows other programs to call the original EXE's entry point as a function.</p><li><p>We create supporting arrays:</p> <ul><li>Function names array: Contains the name of our exported function<li>Function addresses array: Contains the RVA of the original entry point<li>Ordinals array: Maps between names and addresses (we use ordinal 0)</ul></ol><h3 id=7-updating-pe-headers>7. Updating PE Headers</h3><p>Finally, we update the PE headers to point to our new export directory:<pre class="language-cpp z-code" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-source z-c++">IMAGE_DATA_DIRECTORY<span class="z-keyword z-operator z-c++">*</span> export_dir_entry <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-function-call z-c++">peforge<span class="z-punctuation z-accessor z-double-colon z-c++">::</span><span class="z-variable z-function z-c++">get_directory_entry</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">buffer<span class="z-punctuation z-separator z-c++">,</span> IMAGE_DIRECTORY_ENTRY_EXPORT</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span><span class="z-source z-c++">export_dir_entry<span class="z-punctuation z-accessor z-arrow z-c++">-></span><span class="z-variable z-other z-readwrite z-member z-c++">VirtualAddress</span> <span class="z-keyword z-operator z-assignment z-c">=</span> export_table_rva<span class="z-punctuation z-terminator z-c++">;</span>
</span><span class="z-source z-c++">export_dir_entry<span class="z-punctuation z-accessor z-arrow z-c++">-></span><span class="z-variable z-other z-readwrite z-member z-c++">Size</span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-keyword z-operator z-word z-c++">sizeof</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span><span class="z-meta z-group z-c++">IMAGE_EXPORT_DIRECTORY</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><h2 id=using-the-converter>Using the Converter</h2><p>The converter can be used from the command line like this:<pre class="language-bash z-code" data-lang=bash><code class=language-bash data-lang=bash><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">exe2dll</span></span><span class="z-meta z-function-call z-arguments z-shell"> input.exe output.dll Start</span>
</span></code></pre><p>Where:<ul><li><code>input.exe</code> is the source executable<li><code>output.dll</code> is the name of the DLL to create<li><code>Start</code> is the name of the exported function (usually the original entry point)</ul><p>The tool will verify the input file, perform the conversion, and create a new DLL with the specified exported function.<h2 id=demo>Demo</h2><p>Below are some screenshots to illustrate the process and results:<h3 id=1-running-the-original-exe>1. Running the Original EXE</h3><p><img alt="Running the original EXE" src=https://sonx4444.github.io/posts/converting-exes-to-dlls/images/running-original-exe.png><p><em>The original executable running as a standalone application.</em><h3 id=2-running-the-converted-dll-via-rundll32>2. Running the Converted DLL via rundll32</h3><p><img alt="Running the DLL with rundll32" src=https://sonx4444.github.io/posts/converting-exes-to-dlls/images/running-dll-with-rundll32.png><p><em>The converted DLL is executed using <code>rundll32</code>, calling the exported function.</em><h3 id=3-system-informer-showing-the-dll-loaded>3. System Informer Showing the DLL Loaded</h3><p><img alt="System Informer showing DLL loaded" src=https://sonx4444.github.io/posts/converting-exes-to-dlls/images/system-informer-showing-dll-loaded.png><p><em>System Informer confirms the DLL is loaded into the process space via <code>rundll32</code>.</em><h3 id=4-inspecting-the-dll-in-a-pe-reader>4. Inspecting the DLL in a PE Reader</h3><p><img alt="PE Reader view of the DLL" src=https://sonx4444.github.io/posts/converting-exes-to-dlls/images/pe-reader-view-of-dll.png><p><em>The converted DLL opened in a PE file reader, showing the new export directory.</em><h2 id=conclusion>Conclusion</h2><p>Converting an EXE to a DLL involves understanding the PE file format, carefully modifying headers, redirecting entry points, and making use of code caves to insert new data. By following these steps, you can repurpose executables as DLLs and expose their functionality to other programs. I hope this walkthrough has clarified the process and inspired you to explore PE file manipulation further.<p>You can find the full source code in my <a href=https://github.com/sonx4444/exe2dll>GitHub repository</a>.<p>Happy hacking!</section></article></main></div></div><div class=right-content></div>